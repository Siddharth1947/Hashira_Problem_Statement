import com.google.gson.*;
import java.io.*;
import java.math.BigInteger;
import java.nio.file.*;
import java.util.*;

public class ShamirSecretSharing {
    private static final BigInteger MODULUS = new BigInteger("340282366920938463463374607431768211507"); // Prime near 2^128

    public static void main(String[] args) {
        String[] inputFiles = {"input1.json", "input2.json"};
        for (String inputFile : inputFiles) {
            try {
                String jsonContent = new String(Files.readAllBytes(Paths.get(inputFile)));
                JsonObject jsonObject = JsonParser.parseString(jsonContent).getAsJsonObject();

                int n = jsonObject.getAsJsonObject("keys").get("n").getAsInt();
                int k = jsonObject.getAsJsonObject("keys").get("k").getAsInt();

                Map<BigInteger, BigInteger> shares = new LinkedHashMap<>();

                for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {
                    if (entry.getKey().equals("keys")) continue;

                    BigInteger x = new BigInteger(entry.getKey());
                    JsonObject valObj = entry.getValue().getAsJsonObject();
                    int base = valObj.get("base").getAsInt();
                    String value = valObj.get("value").getAsString();
                    BigInteger y;

                    if (isExpression(value)) {
                        y = evaluateExpression(value);
                    } else {
                        y = decodeBase(value, base);
                    }

                    shares.put(x, y);
                }

                Set<List<Map.Entry<BigInteger, BigInteger>>> combinations = generateKCombinations(shares.entrySet(), k);
                Map<BigInteger, Integer> frequencyMap = new HashMap<>();

                for (List<Map.Entry<BigInteger, BigInteger>> combo : combinations) {
                    List<BigInteger> xs = new ArrayList<>();
                    List<BigInteger> ys = new ArrayList<>();
                    for (Map.Entry<BigInteger, BigInteger> point : combo) {
                        xs.add(point.getKey());
                        ys.add(point.getValue());
                    }
                    BigInteger secret = lagrangeInterpolation(xs, ys, MODULUS);
                    frequencyMap.put(secret, frequencyMap.getOrDefault(secret, 0) + 1);
                }

                BigInteger finalSecret = frequencyMap.entrySet().stream()
                        .max(Comparator.comparingInt(Map.Entry::getValue))
                        .get().getKey();

                System.out.println("Secret from " + inputFile + ": " + finalSecret);
            } catch (IOException | JsonParseException e) {
                System.err.println("Error processing file: " + inputFile);
                e.printStackTrace();
            }
        }
    }

    private static boolean isExpression(String str) {
        return str.contains("(") && str.contains(")");
    }

    public static BigInteger evaluateExpression(String expr) {
        expr = expr.trim().toUpperCase();
        if (expr.startsWith("SUM(")) {
            String[] nums = expr.substring(4, expr.length() - 1).split(",");
            BigInteger sum = BigInteger.ZERO;
            for (String num : nums) sum = sum.add(new BigInteger(num.trim()));
            return sum;
        } else if (expr.startsWith("MULTIPLY(")) {
            String[] nums = expr.substring(9, expr.length() - 1).split(",");
            BigInteger prod = BigInteger.ONE;
            for (String num : nums) prod = prod.multiply(new BigInteger(num.trim()));
            return prod;
        } else if (expr.startsWith("HCF(")) {
            String[] nums = expr.substring(4, expr.length() - 1).split(",");
            BigInteger a = new BigInteger(nums[0].trim());
            BigInteger b = new BigInteger(nums[1].trim());
            return a.gcd(b);
        } else if (expr.startsWith("LCM(")) {
            String[] nums = expr.substring(4, expr.length() - 1).split(",");
            BigInteger a = new BigInteger(nums[0].trim());
            BigInteger b = new BigInteger(nums[1].trim());
            return a.multiply(b).divide(a.gcd(b));
        } else {
            return new BigInteger(expr);
        }
    }

    public static BigInteger decodeBase(String value, int base) {
        return new BigInteger(value.trim(), base);
    }

    public static Set<List<Map.Entry<BigInteger, BigInteger>>> generateKCombinations(Set<Map.Entry<BigInteger, BigInteger>> entries, int k) {
        List<Map.Entry<BigInteger, BigInteger>> list = new ArrayList<>(entries);
        Set<List<Map.Entry<BigInteger, BigInteger>>> result = new HashSet<>();
        backtrack(list, k, 0, new ArrayList<>(), result);
        return result;
    }

    private static void backtrack(List<Map.Entry<BigInteger, BigInteger>> list, int k, int start, List<Map.Entry<BigInteger, BigInteger>> temp, Set<List<Map.Entry<BigInteger, BigInteger>>> result) {
        if (temp.size() == k) {
            result.add(new ArrayList<>(temp));
            return;
        }
        for (int i = start; i < list.size(); i++) {
            temp.add(list.get(i));
            backtrack(list, k, i + 1, temp, result);
            temp.remove(temp.size() - 1);
        }
    }

    public static BigInteger lagrangeInterpolation(List<BigInteger> xs, List<BigInteger> ys, BigInteger mod) {
        BigInteger result = BigInteger.ZERO;
        for (int i = 0; i < xs.size(); i++) {
            BigInteger xi = xs.get(i);
            BigInteger yi = ys.get(i);
            BigInteger term = yi;
            for (int j = 0; j < xs.size(); j++) {
                if (i == j) continue;
                BigInteger xj = xs.get(j);
                BigInteger numerator = xj.negate().mod(mod);
                BigInteger denominator = xi.subtract(xj).mod(mod);
                term = term.multiply(numerator).mod(mod);
                term = term.multiply(denominator.modInverse(mod)).mod(mod);
            }
            result = result.add(term).mod(mod);
        }
        return result;
    }
}
